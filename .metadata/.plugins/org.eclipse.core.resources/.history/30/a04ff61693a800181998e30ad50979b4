package com.adhiraj.algorithmsi.queue;

import java.util.NoSuchElementException;

public class ArrayQueue<I> {

	private I[] queue;
	private int head;
	private int tail;

	@SuppressWarnings("unchecked")
	public ArrayQueue() {
		queue = (I[]) new Object[1];
		head = -1;
		tail = -1;
	}

	public void enqueue(I item) {
		if (head == -1 && tail == -1) {
			queue[++head] = item;
			tail = head;
		} else if ((head == 0 && tail == queue.length - 1) || head == tail + 1) {
			resize(queue.length * 2);
			queue[++tail] = item;
		} else if (tail == queue.length - 1) {
			tail = 0;
			queue[tail] = item;
		}
	}

	public I dequeue() {
		if (isEmpty()) {
			throw new NoSuchElementException("Stack underflow");
		}

		I item;
		if (head == tail) {
			item = queue[head];
			head = -1;
			tail = -1;
		} else if (head == queue.length - 1) {
			item = queue[head];
			head = 0;
		} else {
			item = queue[head];
			queue[head++] = null;
		}
		return item;
	}

	public I peek() {
		if (isEmpty()) {
			throw new NoSuchElementException("Stack underflow");
		}
		return queue[head];
	}

	public int size() {
		if (head == -1 && tail == -1) {
			return 0;
		} else if (head <= tail) {
			return tail - head + 1;
		} else {
			return queue.length - head + tail + 1;
		}
	}

	public boolean isEmpty() {
		return head == -1 && tail == -1;

	}

	@SuppressWarnings("unchecked")
	private void resize(int capacity) {
		assert capacity >= size();

		I[] newQueue = (I[]) new Object[capacity];
		if (head <= tail) {
			for (int i = head, j = 0; i <= tail; i++) {
				newQueue[j++] = queue[i];
			}
		} else {
			int j = 0;
			for (int i = head; i < queue.length; i++) {
				newQueue[j++] = queue[i];
			}
			for (int i = 0; i <= tail; i++) {
				newQueue[j++] = queue[i];
			}
		}
	}

	// public String toString() { StringBuilder s = new StringBuilder(); for (Item
	// item : this) s.append(item + " "); return s.toString(); }

}
